<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CSV Diff & Excel Report Tool</title>
    <!-- Load Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom styles for better readability and structure */
        body { font-family: 'Inter', sans-serif; background-color: #f7f9fb; }
        .card { background-color: white; border-radius: 1rem; box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -2px rgba(0, 0, 0, 0.1); }
        .input-group { display: flex; flex-direction: column; margin-bottom: 1rem; }
        .input-group label { margin-bottom: 0.25rem; font-weight: 500; color: #374151; }
        
        /* New Row-Wise Styles */
        .mismatch-cell { color: #dc2626; font-weight: 600; }
        .source-row { background-color: #eff6ff; /* Light Blue/Blue-50 */ }
        .dest-row { background-color: #f9fafb; /* Very Light Gray/Gray-50 */ }
        .unmatched-record { background-color: #fef2f2; /* Light Red/Red-50 for SOURCE/DESTINATION_ONLY */ }
    </style>
    <!-- Load PapaParse (for handling different delimiters) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
    <!-- Load SheetJS (xlsx) (for generating Excel files with styles) -->
    <script src="https://cdn.sheetjs.com/xlsx-0.20.2/package/dist/xlsx.full.min.js"></script>
</head>
<body class="p-4 md:p-8 min-h-screen flex items-start justify-center">

    <div class="w-full max-w-5xl">
        <header class="text-center mb-8">
            <h1 class="text-3xl font-extrabold text-gray-900 mb-2">CSV Data Comparison Tool</h1>
            <p class="text-gray-500">Compare a Comma-separated (Source) file against a Pipe-separated (Destination) file and generate a styled Excel report.</p>
        </header>

        <div class="card p-6 md:p-8 space-y-6">
            <!-- 1. Configuration Inputs -->
            <div class="grid grid-cols-1 md:grid-cols-3 gap-6">
                <!-- File 1: Source -->
                <div class="input-group">
                    <label for="csvFile1">File 1 (Source: Comma-separated , )</label>
                    <input type="file" id="csvFile1" accept=".csv" class="p-2 border border-gray-300 rounded-lg hover:border-indigo-500 transition duration-150">
                </div>

                <!-- File 2: Destination -->
                <div class="input-group">
                    <label for="csvFile2">File 2 (Destination: Pipe-separated | )</label>
                    <input type="file" id="csvFile2" accept=".csv, .txt" class="p-2 border border-gray-300 rounded-lg hover:border-indigo-500 transition duration-150">
                </div>

                <!-- Key Configuration Block -->
                <div class="input-group">
                    <label class="mb-2 font-medium text-gray-700">Select Comparison Key Type:</label>
                    <div class="flex space-x-4 mb-3">
                        <div class="flex items-center">
                            <input type="radio" id="keyTypeSingle" name="keyType" value="single" checked class="h-4 w-4 text-indigo-600 border-gray-300 focus:ring-indigo-500">
                            <label for="keyTypeSingle" class="ml-2 block text-sm font-medium text-gray-700">Single Primary Key</label>
                        </div>
                        <div class="flex items-center">
                            <input type="radio" id="keyTypeComposite" name="keyType" value="composite" class="h-4 w-4 text-indigo-600 border-gray-300 focus:ring-indigo-500">
                            <label for="keyTypeComposite" class="ml-2 block text-sm font-medium text-gray-700">Composite Key</label>
                        </div>
                    </div>
                    
                    <label id="pkLabel" for="pkColumn" class="font-medium text-gray-500 text-sm">Primary Key Column Name (e.g., ID)</label>
                    <input type="text" id="pkColumn" value="ID" placeholder="Enter a single column name" class="p-2 border border-gray-300 rounded-lg focus:ring-indigo-500 focus:border-indigo-500">
                    <p id="pkHelpText" class="mt-1 text-xs text-gray-500">Only enter the name of the single unique column used for matching.</p>
                </div>

                <!-- NEW: Header Filter File Input -->
                <div class="input-group md:col-span-3">
                    <label for="headerFile">Optional: Header Filter File (Pipe-separated | )</label>
                    <input type="file" id="headerFile" accept=".csv, .txt" class="p-2 border border-gray-300 rounded-lg hover:border-green-500 transition duration-150">
                    <p class="mt-1 text-xs text-gray-500">If provided, the final report will ONLY contain these headers (plus the keys), in the order specified, which is useful for cleaning up the final report.</p>
                </div>
            </div>

            <!-- 2. Action Button -->
            <div class="flex flex-col sm:flex-row justify-center space-y-4 sm:space-y-0 sm:space-x-4 pt-4 border-t border-gray-200">
                <button onclick="compareAndExport()" id="compareButton" class="px-6 py-3 text-lg font-semibold rounded-full bg-indigo-600 text-white hover:bg-indigo-700 transition duration-200 shadow-md disabled:opacity-50" disabled>
                    Compare & Generate Excel Report (.xlsx)
                </button>
                <button onclick="summarizeInsights()" id="llmButton" class="px-6 py-3 text-lg font-semibold rounded-full bg-green-500 text-white hover:bg-green-600 transition duration-200 shadow-md disabled:opacity-50" disabled>
                    ✨ Summarize Comparison Insights
                </button>
            </div>

            <!-- 3. Status/Error Message -->
            <div id="statusMessage" class="text-center p-3 rounded-lg hidden"></div>
            <div id="llmResult" class="card p-4 bg-yellow-50 border-yellow-200 border-l-4 hidden mt-6">
                <h3 class="font-bold text-yellow-800 mb-2">LLM Data Quality Summary:</h3>
                <p id="llmSummaryText" class="text-yellow-700 whitespace-pre-line"></p>
            </div>


            <!-- 4. Result Preview Area -->
            <h2 id="previewHeader" class="text-2xl font-bold text-gray-800 pt-8 hidden">Comparison Preview (Max 100 Rows)</h2>
            <div id="comparisonPreview" class="w-full overflow-x-auto mt-4 max-h-96">
                <!-- Comparison table will be inserted here -->
            </div>
        </div>
    </div>

    <script>
        const API_URL = "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=";
        const apiKey = ""; // Canvas will provide this at runtime

        const statusMessage = document.getElementById('statusMessage');
        const previewHeader = document.getElementById('previewHeader');
        const comparisonPreview = document.getElementById('comparisonPreview');
        const compareButton = document.getElementById('compareButton');
        const llmButton = document.getElementById('llmButton');
        const csvFile1 = document.getElementById('csvFile1');
        const csvFile2 = document.getElementById('csvFile2');
        const pkColumnInput = document.getElementById('pkColumn');
        const pkLabel = document.getElementById('pkLabel');
        const pkHelpText = document.getElementById('pkHelpText');
        const llmResultDiv = document.getElementById('llmResult');
        const llmSummaryText = document.getElementById('llmSummaryText');
        const headerFile = document.getElementById('headerFile'); // NEW reference

        // Global storage for the last successful comparison result
        let lastComparisonResult = null;
        let sourceRecordCount = 0;
        let destRecordCount = 0;

        // Get references to radio buttons
        const keyTypeSingle = document.getElementById('keyTypeSingle');
        const keyTypeComposite = document.getElementById('keyTypeComposite');

        // --- UI/UX Helper Functions ---

        /**
         * Updates the input field guidance based on the selected key type.
         */
        function handleKeyModeChange() {
            if (keyTypeSingle.checked) {
                pkLabel.textContent = "Primary Key Column Name (e.g., ID)";
                pkColumnInput.placeholder = "Enter a single column name";
                pkHelpText.textContent = "Only enter the name of the single unique column used for matching.";
            } else {
                pkLabel.textContent = "Composite Key Columns (e.g., FirstName,LastName,DOB)";
                pkColumnInput.placeholder = "Enter comma-separated column names";
                pkHelpText.textContent = "Enter two or more column names, separated by commas, to create a unique identifier.";
            }
        }
        
        // Add listeners for key type change
        keyTypeSingle.addEventListener('change', handleKeyModeChange);
        keyTypeComposite.addEventListener('change', handleKeyModeChange);
        
        /**
         * Utility to enable the button only when both files are selected.
         */
        function checkFilesReady() {
            if (csvFile1.files.length > 0 && csvFile2.files.length > 0) {
                compareButton.disabled = false;
            } else {
                compareButton.disabled = true;
            }
        }

        csvFile1.addEventListener('change', checkFilesReady);
        csvFile2.addEventListener('change', checkFilesReady);

        /**
         * Shows a temporary status or error message.
         * @param {string} message - The message content.
         * @param {string} type - 'success', 'error', or 'info'.
         */
        function showMessage(message, type = 'info') {
            statusMessage.textContent = message;
            statusMessage.className = 'text-center p-3 rounded-lg';
            statusMessage.classList.remove('hidden');

            switch (type) {
                case 'success':
                    statusMessage.classList.add('bg-green-100', 'text-green-800');
                    break;
                case 'error':
                    statusMessage.classList.add('bg-red-100', 'text-red-800');
                    break;
                case 'info':
                default:
                    statusMessage.classList.add('bg-blue-100', 'text-blue-800');
                    break;
            }

            // Clear after 5 seconds
            setTimeout(() => {
                statusMessage.classList.add('hidden');
            }, 5000);
        }

        /**
         * Utility for exponential backoff during API calls.
         * @param {Function} fn - The function to retry.
         * @param {number} maxRetries - Maximum number of retries.
         */
        async function withExponentialBackoff(fn, maxRetries = 5) {
            for (let i = 0; i < maxRetries; i++) {
                try {
                    return await fn();
                } catch (error) {
                    if (i === maxRetries - 1 || error.message.includes('400')) {
                        throw error;
                    }
                    const delay = Math.pow(2, i) * 1000 + Math.random() * 1000;
                    await new Promise(resolve => setTimeout(resolve, delay));
                }
            }
        }


        // --- Core Data Functions ---

        /**
         * Parses a file using PapaParse.
         * @param {File} file - The file object.
         * @param {string} delimiter - The delimiter character (',' or '|').
         * @returns {Promise<Array<Object>>} - Parsed data rows.
         */
        function parseFile(file, delimiter) {
            return new Promise((resolve, reject) => {
                Papa.parse(file, {
                    header: true,
                    skipEmptyLines: true,
                    delimiter: delimiter,
                    complete: (results) => {
                        if (results.errors.length > 0) {
                            reject(new Error(`Parsing error in file: ${results.errors[0].message}`));
                            return;
                        }
                        resolve(results.data);
                    },
                    error: (error) => {
                        reject(new Error(error.message));
                    }
                });
            });
        }
        
        /**
         * Generates a composite key string from a data row and a list of column names.
         * @param {Object} row - The data row object.
         * @param {Array<string>} pkColumns - Array of column names to concatenate.
         * @returns {string} - The composite key.
         */
        function getCompositeKey(row, pkColumns) {
            // Use a highly unlikely separator (e.g., triple pipe)
            return pkColumns.map(col => (row[col] || '').trim().toUpperCase()).join('|||');
        }

        /**
         * Core comparison logic: Matches records and finds cell-level differences using a composite key.
         * Accepts an optional reportHeaders array to filter and order the output columns.
         */
        function performComparison(sourceData, destData, compositeKeyColumns, providedReportHeaders) {
            // 1. Build a Map of Source Data for quick lookup using the composite key
            const sourceMap = new Map();
            sourceData.forEach(row => {
                const compositeKey = getCompositeKey(row, compositeKeyColumns);
                if (compositeKey) {
                    sourceMap.set(compositeKey, row);
                }
            });

            // 2. Identify all unique headers across both files
            const sourceKeys = sourceData.length > 0 ? Object.keys(sourceData[0]) : [];
            const destKeys = destData.length > 0 ? Object.keys(destData[0]) : [];
            const allUniqueHeaders = Array.from(new Set([...sourceKeys, ...destKeys]));
            
            const keySet = new Set(compositeKeyColumns);
            const allAvailableHeadersSet = new Set(allUniqueHeaders);
            
            let nonKeyHeaders;
            
            if (providedReportHeaders && providedReportHeaders.length > 0) {
                // If header filter file is provided, use its headers, exclude keys, and ensure they exist
                nonKeyHeaders = providedReportHeaders
                    .filter(h => !keySet.has(h))
                    .filter(h => allAvailableHeadersSet.has(h));
            } else {
                // Otherwise, use all available non-key headers
                nonKeyHeaders = allUniqueHeaders.filter(h => !keySet.has(h));
            }

            const comparisonRows = []; // Stores one object per key
            const matchedPks = new Set();

            // 3. Compare Destination data against Source
            destData.forEach(destRow => {
                const compositeKey = getCompositeKey(destRow, compositeKeyColumns);
                const sourceRow = sourceMap.get(compositeKey);
                matchedPks.add(compositeKey);

                const comparisonRow = {
                    keyValues: compositeKeyColumns.map(h => ({
                        header: h,
                        source: sourceRow ? (sourceRow[h] || '') : (destRow[h] || ''),
                        dest: destRow[h] || '',
                    })),
                    status: sourceRow ? 'MATCHED' : 'DESTINATION_ONLY',
                    diffs: 0,
                    // cells structure holds the comparison result for the non-key (data) columns
                    cells: {} 
                };

                // Compare non-key columns for differences (using the filtered list)
                nonKeyHeaders.forEach(header => {
                    // Normalize values for comparison (trim and coalesce to empty string)
                    const sourceValue = sourceRow ? (sourceRow[header] || '').trim() : '';
                    const destValue = (destRow[header] || '').trim();

                    const isDiff = sourceValue !== destValue;

                    if (isDiff) {
                        comparisonRow.diffs++;
                    }

                    comparisonRow.cells[header] = {
                        source: sourceValue,
                        dest: destValue,
                        isDiff: isDiff
                    };
                });

                if (comparisonRow.diffs > 0) {
                    comparisonRow.status = 'MISMATCHED';
                }
                comparisonRows.push(comparisonRow);
            });

            // 4. Identify Source-Only records (Deletions/Missing in Destination)
            sourceData.forEach(sourceRow => {
                const compositeKey = getCompositeKey(sourceRow, compositeKeyColumns);
                
                if (!matchedPks.has(compositeKey) && sourceMap.has(compositeKey)) {
                    const comparisonRow = {
                        keyValues: compositeKeyColumns.map(h => ({
                            header: h,
                            source: sourceRow[h] || '',
                            dest: '' 
                        })),
                        status: 'SOURCE_ONLY',
                        diffs: 0, 
                        cells: {}
                    };

                    nonKeyHeaders.forEach(header => {
                        comparisonRow.cells[header] = {
                            source: sourceRow[header] || '',
                            dest: '', 
                            isDiff: true // Mark as diff since record is missing
                        };
                    });
                    comparisonRows.push(comparisonRow);
                }
            });
            
            return { 
                keyHeaders: compositeKeyColumns, 
                nonKeyHeaders: nonKeyHeaders, 
                rows: comparisonRows 
            };
        }

        // --- LLM Insight Generation Function (Unchanged) ---

        function getComparisonMetrics(comparisonResult) {
            const { rows, nonKeyHeaders } = comparisonResult;
            let matchedCount = 0;
            let mismatchedCount = 0;
            let sourceOnlyCount = 0;
            let destOnlyCount = 0;
            const diffsPerField = nonKeyHeaders.reduce((acc, header) => {
                acc[header] = 0;
                return acc;
            }, {});

            rows.forEach(row => {
                switch (row.status) {
                    case 'MATCHED':
                        matchedCount++;
                        break;
                    case 'MISMATCHED':
                        mismatchedCount++;
                        // Count field-level diffs
                        Object.keys(row.cells).forEach(header => {
                            if (row.cells[header].isDiff) {
                                diffsPerField[header]++;
                            }
                        });
                        break;
                    case 'SOURCE_ONLY':
                        sourceOnlyCount++;
                        break;
                    case 'DESTINATION_ONLY':
                        destOnlyCount++;
                        break;
                }
            });

            // Convert diffsPerField to an array and sort descending
            const topDiffFields = Object.entries(diffsPerField)
                .sort(([, a], [, b]) => b - a)
                .slice(0, 5) // Get top 5 fields
                .map(([field, count]) => `${field} (${count})`);

            return {
                totalSource: sourceRecordCount,
                totalDestination: destRecordCount,
                matched: matchedCount,
                mismatched: mismatchedCount,
                sourceOnly: sourceOnlyCount,
                destOnly: destOnlyCount,
                topDiffFields: topDiffFields,
            };
        }

        async function summarizeInsights() {
            if (!lastComparisonResult) {
                showMessage("Please run the comparison first to generate results.", 'info');
                return;
            }
            
            llmResultDiv.classList.add('hidden');
            llmSummaryText.textContent = '';
            llmButton.disabled = true;
            llmButton.textContent = "Analyzing...";

            try {
                const metrics = getComparisonMetrics(lastComparisonResult);
                
                const prompt = `Analyze the following data comparison metrics for a Source vs. Destination CSV comparison. The goal is to identify key data quality issues in a concise, professional summary for a data analyst.

Total Source Records: ${metrics.totalSource}
Total Destination Records: ${metrics.totalDestination}
Matched Records (No Mismatch): ${metrics.matched}
Mismatched Records (Data Differences): ${metrics.mismatched}
Source-Only Records (Missing in Destination): ${metrics.sourceOnly}
Destination-Only Records (Extra in Destination): ${metrics.destOnly}
Top 5 Fields with Mismatches (Field Name and Count): ${metrics.topDiffFields.join(', ') || 'None'}

Provide a concise, 3-4 sentence executive summary focused on the magnitude of the errors and the highest priority fields that need investigation.`;

                const payload = {
                    contents: [{ parts: [{ text: prompt }] }],
                    systemInstruction: {
                        parts: [{ text: "You are a professional Data Quality Analyst. Provide a clear, actionable, and concise summary of the comparison results. Use simple markdown formatting (e.g., bolding) but no headers or lists." }]
                    },
                };

                const response = await withExponentialBackoff(() => fetch(API_URL + apiKey, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                }));
                
                if (!response.ok) {
                    throw new Error(`API call failed with status: ${response.status}`);
                }

                const result = await response.json();
                const summary = result.candidates?.[0]?.content?.parts?.[0]?.text || "Failed to generate summary.";
                
                llmSummaryText.textContent = summary;
                llmResultDiv.classList.remove('hidden');
                showMessage("Insights generated by Gemini API successfully.", 'success');

            } catch (error) {
                console.error("LLM Error:", error);
                llmSummaryText.textContent = `Error generating summary: ${error.message}`;
                llmResultDiv.classList.remove('hidden');
                showMessage("Failed to generate insights. Check console for details.", 'error');
            } finally {
                llmButton.disabled = false;
                llmButton.textContent = "✨ Summarize Comparison Insights";
            }
        }
        
        // --- NEW: Summary Sheet Generation ---
        
        /**
         * Creates and appends the Summary worksheet to the workbook.
         */
        function createSummarySheet(wb, metrics) {
            const summaryData = [
                [{ v: "Metric", t: 's', s: { font: { bold: true } } }, { v: "Value", t: 's', s: { font: { bold: true } } }],
                [{ v: '---', t: 's' }, { v: '---', t: 's' }],
                ["Total Source Records", metrics.totalSource],
                ["Total Destination Records", metrics.totalDestination],
                [{ v: '---', t: 's' }, { v: '---', t: 's' }],
                [{ v: "Matched Records (Exact Match)", t: 's', s: { font: { bold: true } } }, metrics.matched],
                [{ v: "Mismatched Records (Data Differences)", t: 's', s: { font: { bold: true, color: { rgb: "FFCC0000" } } } }, metrics.mismatched],
                [{ v: "Source-Only Records (Missing in Dest)", t: 's', s: { font: { bold: true, color: { rgb: "FFCC0000" } } } }, metrics.sourceOnly],
                [{ v: "Destination-Only Records (Extra in Dest)", t: 's', s: { font: { bold: true, color: { rgb: "FFCC0000" } } } }, metrics.destOnly],
                [{ v: '---', t: 's' }, { v: '---', t: 's' }],
                [{ v: "Fields with Mismatches (Top 5)", t: 's', s: { font: { bold: true } } }, { v: "Count", t: 's', s: { font: { bold: true } } }],
                [{ v: '---', t: 's' }, { v: '---', t: 's' }],
            ];

            // Add field-level difference counts
            metrics.topDiffFields.forEach(fieldCountStr => {
                const parts = fieldCountStr.match(/(.*) \((.*)\)/);
                if (parts) {
                    summaryData.push([parts[1], parseInt(parts[2], 10)]);
                }
            });

            const wsSummary = XLSX.utils.aoa_to_sheet(summaryData);

            // Set column widths for better display
            const cols = [{ wch: 40 }, { wch: 15 }];
            wsSummary['!cols'] = cols;
            
            XLSX.utils.book_append_sheet(wb, wsSummary, "Summary");
        }


        // --- Export and Render Functions ---

        /**
         * Generates and triggers download of the Excel (.xlsx) file with styling.
         */
        function exportToExcel(comparisonResult) {
            const { keyHeaders, nonKeyHeaders, rows } = comparisonResult;
            
            // Define the style object for red font and row backgrounds in SheetJS
            const RED_FONT_STYLE = { font: { name: "Inter", color: { rgb: "FFFF0000" } } };
            const SOURCE_FILL_STYLE = { fill: { patternType: "solid", fgColor: { rgb: "FFE0F2FE" } } }; // Light Blue
            const DEST_FILL_STYLE = { fill: { patternType: "solid", fgColor: { rgb: "FFF3F4F6" } } }; // Light Gray
            const UNMATCHED_FILL_STYLE = { fill: { patternType: "solid", fgColor: { rgb: "FFFEE2E2" } } }; // Light Red (Red-100)

            // Create a blank SheetJS workbook
            const wb = XLSX.utils.book_new();
            
            // 1. Create Summary Sheet
            const metrics = getComparisonMetrics(comparisonResult);
            createSummarySheet(wb, metrics); 

            // 2. Create Comparison Report Sheet
            const ws = XLSX.utils.aoa_to_sheet([]);

            // Write Headers (STATUS, File_Source, Key Columns, then all Non-Key Columns)
            const headers = [{ v: 'STATUS', t: 's' }, { v: 'File_Source', t: 's' }];
            
            keyHeaders.forEach(header => {
                headers.push({ v: `${header} (Key)`, t: 's' });
            });

            nonKeyHeaders.forEach(header => {
                headers.push({ v: header, t: 's' }); // Only one header per data column
            });
            
            XLSX.utils.sheet_add_aoa(ws, [headers.map(h => h.v)], { origin: 'A1' });

            // Write Data Rows (Generating two rows for MATCHED/MISMATCHED keys)
            rows.forEach(row => {
                const isMatchedOrMismatched = row.status === 'MATCHED' || row.status === 'MISMATCHED';

                // --- 2a. Generate Source Row ---
                if (row.status !== 'DESTINATION_ONLY') { // Source data exists
                    const sourceRowData = [];
                    const rowFillStyle = isMatchedOrMismatched ? SOURCE_FILL_STYLE : UNMATCHED_FILL_STYLE;
                    
                    // STATUS and File_Source
                    sourceRowData.push({ v: row.status, t: 's', s: rowFillStyle });
                    sourceRowData.push({ v: 'Source', t: 's', s: rowFillStyle });
                    
                    // Key Columns (Source Value)
                    row.keyValues.forEach(kv => {
                        sourceRowData.push({ v: kv.source, t: 's', s: rowFillStyle }); 
                    });

                    // Data Columns (Source Value)
                    nonKeyHeaders.forEach(header => {
                        const cellData = row.cells[header];
                        const cellValue = cellData ? cellData.source : '';
                        
                        const cell = { v: cellValue, t: 's', s: rowFillStyle };
                        // Apply red font style if Mismatch is true AND we are in a Mismatched/Matched block
                        if (isMatchedOrMismatched && cellData && cellData.isDiff) {
                            cell.s = { ...rowFillStyle, ...RED_FONT_STYLE };
                        }
                        sourceRowData.push(cell);
                    });

                    XLSX.utils.sheet_add_aoa(ws, [sourceRowData], { origin: -1 });
                }

                // --- 2b. Generate Destination Row ---
                if (row.status !== 'SOURCE_ONLY') { // Destination data exists
                    const destRowData = [];
                    const rowFillStyle = isMatchedOrMismatched ? DEST_FILL_STYLE : UNMATCHED_FILL_STYLE;

                    // STATUS and File_Source
                    destRowData.push({ v: row.status, t: 's', s: rowFillStyle });
                    destRowData.push({ v: 'Destination', t: 's', s: rowFillStyle });
                    
                    // Key Columns (Destination Value)
                    row.keyValues.forEach(kv => {
                        destRowData.push({ v: kv.dest, t: 's', s: rowFillStyle }); 
                    });

                    // Data Columns (Destination Value)
                    nonKeyHeaders.forEach(header => {
                        const cellData = row.cells[header];
                        const cellValue = cellData ? cellData.dest : '';

                        const cell = { v: cellValue, t: 's', s: rowFillStyle };
                        // Apply red font style if Mismatch is true AND we are in a Mismatched/Matched block
                        if (isMatchedOrMismatched && cellData && cellData.isDiff) {
                            cell.s = { ...rowFillStyle, ...RED_FONT_STYLE };
                        }
                        destRowData.push(cell);
                    });

                    XLSX.utils.sheet_add_aoa(ws, [destRowData], { origin: -1 });
                }
            });

            // Finalize and Download
            XLSX.utils.book_append_sheet(wb, ws, "Comparison Report");
            XLSX.writeFile(wb, "CSV_Comparison_Report.xlsx");
        }


        /**
         * Clears the UI and displays the comparison results in an HTML table.
         */
        function renderPreview(comparisonResult) {
            const { keyHeaders, nonKeyHeaders, rows } = comparisonResult;
            
            // Show header and clear previous content
            previewHeader.classList.remove('hidden');
            comparisonPreview.innerHTML = '';
            
            // Limit to 100 rows for performance
            const rowsToDisplay = rows.slice(0, 100);

            if (rowsToDisplay.length === 0) {
                 comparisonPreview.innerHTML = '<p class="text-center text-gray-500 p-8">No records found matching your comparison criteria or the files were empty.</p>';
                 return;
            }

            let html = '<table class="min-w-full divide-y divide-gray-300 rounded-xl overflow-hidden shadow-lg">';

            // Table Header Row
            html += '<thead class="bg-gray-100 sticky top-0">';
            html += '<tr>';
            html += `<th class="px-3 py-3 text-xs font-medium text-gray-500 uppercase tracking-wider text-left">STATUS</th>`;
            html += `<th class="px-3 py-3 text-xs font-medium text-gray-700 uppercase tracking-wider text-left">File_Source</th>`;
            
            // Key Columns Header
            keyHeaders.forEach(header => {
                html += `<th class="px-3 py-3 text-xs font-medium text-gray-500 uppercase tracking-wider text-left">${header} (Key)</th>`;
            });
            
            // Non-Key Columns Header (only once)
            nonKeyHeaders.forEach(header => {
                html += `<th class="px-6 py-3 text-xs font-medium text-gray-700 uppercase tracking-wider text-left border-l border-gray-300">${header}</th>`;
            });
            html += '</tr>';
            html += '</thead>';

            // Table Body
            html += '<tbody class="divide-y divide-gray-200 bg-white">';
            rowsToDisplay.forEach(row => {
                const isMatchedOrMismatched = row.status === 'MATCHED' || row.status === 'MISMATCHED';

                // --- 1. Source Row ---
                if (row.status !== 'DESTINATION_ONLY') {
                    const rowClass = isMatchedOrMismatched ? 'source-row' : 'unmatched-record';
                    html += `<tr class="${rowClass} hover:opacity-80 transition duration-100 border-b-2 border-indigo-200/50">`;
                    
                    // STATUS and File_Source
                    html += `<td class="px-3 py-3 whitespace-nowrap text-xs font-semibold ${row.status === 'SOURCE_ONLY' || row.status === 'MISMATCHED' ? 'text-red-600' : 'text-green-600'}">${row.status}</td>`;
                    html += `<td class="px-3 py-3 whitespace-nowrap text-sm font-medium text-indigo-700">Source</td>`;

                    // Key Column Values
                    row.keyValues.forEach(kv => {
                        html += `<td class="px-3 py-3 whitespace-nowrap text-sm font-medium text-gray-900">${kv.source}</td>`;
                    });

                    // Data Cells (Non-Key)
                    nonKeyHeaders.forEach(header => {
                        const cell = row.cells[header];
                        const cellValue = cell ? cell.source : '';
                        
                        let cellClass = 'text-gray-700';
                        if (isMatchedOrMismatched && cell && cell.isDiff) {
                            cellClass = 'mismatch-cell';
                        }
                        
                        html += `<td class="px-6 py-3 whitespace-nowrap text-sm ${cellClass}">${cellValue}</td>`;
                    });
                    
                    html += '</tr>';
                }

                // --- 2. Destination Row ---
                if (row.status !== 'SOURCE_ONLY') {
                    const rowClass = isMatchedOrMismatched ? 'dest-row' : 'unmatched-record';
                    html += `<tr class="${rowClass} hover:opacity-80 transition duration-100">`;
                    
                    // STATUS and File_Source
                    html += `<td class="px-3 py-3 whitespace-nowrap text-xs font-semibold ${row.status === 'DESTINATION_ONLY' || row.status === 'MISMATCHED' ? 'text-red-600' : 'text-green-600'}">${row.status}</td>`;
                    html += `<td class="px-3 py-3 whitespace-nowrap text-sm font-medium text-gray-700">Destination</td>`;

                    // Key Column Values
                    row.keyValues.forEach(kv => {
                        html += `<td class="px-3 py-3 whitespace-nowrap text-sm font-medium text-gray-900">${kv.dest}</td>`;
                    });

                    // Data Cells (Non-Key)
                    nonKeyHeaders.forEach(header => {
                        const cell = row.cells[header];
                        const cellValue = cell ? cell.dest : '';
                        
                        let cellClass = 'text-gray-700';
                        if (isMatchedOrMismatched && cell && cell.isDiff) {
                            cellClass = 'mismatch-cell';
                        }

                        html += `<td class="px-6 py-3 whitespace-nowrap text-sm ${cellClass}">${cellValue}</td>`;
                    });
                    
                    html += '</tr>';
                }
            });
            html += '</tbody>';
            html += '</table>';

            comparisonPreview.innerHTML = html;
        }

        // --- Main Execution Function ---

        async function compareAndExport() {
            const file1 = csvFile1.files[0];
            const file2 = csvFile2.files[0];
            const headerFilterFile = headerFile.files[0]; // NEW

            const pkColumnInputVal = pkColumnInput.value.trim();
            const isSingleKeyMode = keyTypeSingle.checked;
            
            // Get the list of column names, trimming whitespace
            const compositeKeyColumns = pkColumnInputVal.split(',')
                .map(col => col.trim())
                .filter(col => col.length > 0);

            if (!file1 || !file2 || compositeKeyColumns.length === 0) {
                showMessage("Please select both data files and specify at least one column name for the key.", 'error');
                return;
            }

            // Additional validation for single key mode
            if (isSingleKeyMode && compositeKeyColumns.length > 1) {
                showMessage("In 'Single Primary Key' mode, please enter only one column name.", 'error');
                return;
            }

            compareButton.disabled = true;
            llmButton.disabled = true;
            compareButton.textContent = "Processing... (This may take a moment)";
            showMessage("Parsing files and performing comparison...", 'info');
            llmResultDiv.classList.add('hidden'); // Hide previous LLM result

            try {
                // 1. Parse Files
                const sourceData = await parseFile(file1, ',');
                const destData = await parseFile(file2, '|');
                
                sourceRecordCount = sourceData.length;
                destRecordCount = destData.length;
                
                let reportHeaders = null;
                if (headerFilterFile) {
                    const headerData = await parseFile(headerFilterFile, '|');
                    if (headerData.length === 0) {
                        throw new Error("Header Filter File is empty or could not be parsed correctly.");
                    }
                    // The keys of the first row object are the desired headers
                    reportHeaders = Object.keys(headerData[0]);
                }

                if (sourceRecordCount === 0 || destRecordCount === 0) {
                    throw new Error("One or both primary data files are empty or could not be parsed correctly.");
                }

                // Check if all key columns exist in headers of both files
                const sourceHeaders = Object.keys(sourceData[0]);
                const destHeaders = Object.keys(destData[0]);
                
                for (const key of compositeKeyColumns) {
                    if (!sourceHeaders.includes(key) || !destHeaders.includes(key)) {
                        throw new Error(`Key Column '${key}' not found in headers of both data files. Please check spelling/casing.`);
                    }
                }

                // 2. Perform Comparison
                const comparisonResult = performComparison(sourceData, destData, compositeKeyColumns, reportHeaders);
                lastComparisonResult = comparisonResult; // Store result globally

                // 3. Render HTML Preview
                renderPreview(comparisonResult);

                // 4. Generate and Download Excel Report
                exportToExcel(comparisonResult);
                
                // 5. Enable LLM button
                llmButton.disabled = false;

                showMessage(`Successfully compared ${sourceRecordCount} source records against ${destRecordCount} destination records. Excel file downloaded! (See Preview below)`, 'success');

            } catch (error) {
                console.error("Comparison Error:", error);
                // Clear state on error
                lastComparisonResult = null;
                sourceRecordCount = 0;
                destRecordCount = 0;
                llmButton.disabled = true;
                
                // Show a clear message if the preview is empty due to an error
                if (error.message.includes("files are empty")) {
                    comparisonPreview.innerHTML = '<p class="text-center text-red-500 p-8">Error: One or both files are empty. Please check your data.</p>';
                    previewHeader.classList.remove('hidden');
                } else if (error.message.includes("Key Column")) {
                    comparisonPreview.innerHTML = `<p class="text-center text-red-500 p-8">Error: Key column mismatch. ${error.message}</p>`;
                    previewHeader.classList.remove('hidden');
                } else {
                     comparisonPreview.innerHTML = `<p class="text-center text-red-500 p-8">An unexpected error occurred: ${error.message}</p>`;
                     previewHeader.classList.remove('hidden');
                }
                
                showMessage(`Error: ${error.message}`, 'error');
            } finally {
                compareButton.disabled = false;
                compareButton.textContent = "Compare & Generate Excel Report (.xlsx)";
            }
        }

        // Initialize button and UI state
        checkFilesReady();
        handleKeyModeChange(); // Set initial label/placeholder
    </script>
</body>
</html>
