<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CSV Diff & Excel Report Tool</title>
    <!-- Load Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom styles for better readability and structure */
        body { font-family: 'Inter', sans-serif; background-color: #f7f9fb; }
        .card { background-color: white; border-radius: 1rem; box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -2px rgba(0, 0, 0, 0.1); }
        .input-group { display: flex; flex-direction: column; margin-bottom: 1rem; }
        .input-group label { margin-bottom: 0.25rem; font-weight: 500; color: #374151; }
        .mismatch-cell { color: #dc2626; font-weight: 600; }
        .matched-row { background-color: #f0fdf4; }
        .unmatched-row { background-color: #fef2f2; }
    </style>
    <!-- Load PapaParse (for handling different delimiters) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
    <!-- Load SheetJS (xlsx) (for generating Excel files with styles) -->
    <script src="https://cdn.sheetjs.com/xlsx-0.20.2/package/dist/xlsx.full.min.js"></script>
</head>
<body class="p-4 md:p-8 min-h-screen flex items-start justify-center">

    <div class="w-full max-w-5xl">
        <header class="text-center mb-8">
            <h1 class="text-3xl font-extrabold text-gray-900 mb-2">CSV Data Comparison Tool</h1>
            <p class="text-gray-500">Compare a Comma-separated (Source) file against a Pipe-separated (Destination) file and generate a styled Excel report.</p>
        </header>

        <div class="card p-6 md:p-8 space-y-6">
            <!-- 1. Configuration Inputs -->
            <div class="grid grid-cols-1 md:grid-cols-3 gap-6">
                <div class="input-group">
                    <label for="csvFile1">File 1 (Source: Comma-separated , )</label>
                    <input type="file" id="csvFile1" accept=".csv" class="p-2 border border-gray-300 rounded-lg hover:border-indigo-500 transition duration-150">
                </div>

                <div class="input-group">
                    <label for="csvFile2">File 2 (Destination: Pipe-separated | )</label>
                    <input type="file" id="csvFile2" accept=".csv, .txt" class="p-2 border border-gray-300 rounded-lg hover:border-indigo-500 transition duration-150">
                </div>

                <!-- Key Configuration Block (Updated for choice) -->
                <div class="input-group">
                    <label class="mb-2 font-medium text-gray-700">Select Comparison Key Type:</label>
                    <div class="flex space-x-4 mb-3">
                        <div class="flex items-center">
                            <input type="radio" id="keyTypeSingle" name="keyType" value="single" checked class="h-4 w-4 text-indigo-600 border-gray-300 focus:ring-indigo-500">
                            <label for="keyTypeSingle" class="ml-2 block text-sm font-medium text-gray-700">Single Primary Key</label>
                        </div>
                        <div class="flex items-center">
                            <input type="radio" id="keyTypeComposite" name="keyType" value="composite" class="h-4 w-4 text-indigo-600 border-gray-300 focus:ring-indigo-500">
                            <label for="keyTypeComposite" class="ml-2 block text-sm font-medium text-gray-700">Composite Key</label>
                        </div>
                    </div>
                    
                    <label id="pkLabel" for="pkColumn" class="font-medium text-gray-500 text-sm">Primary Key Column Name (e.g., ID)</label>
                    <input type="text" id="pkColumn" value="ID" placeholder="Enter a single column name" class="p-2 border border-gray-300 rounded-lg focus:ring-indigo-500 focus:border-indigo-500">
                    <p id="pkHelpText" class="mt-1 text-xs text-gray-500">Only enter the name of the single unique column used for matching.</p>
                </div>
            </div>

            <!-- 2. Action Button -->
            <div class="flex flex-col sm:flex-row justify-center space-y-4 sm:space-y-0 sm:space-x-4 pt-4 border-t border-gray-200">
                <button onclick="compareAndExport()" id="compareButton" class="px-6 py-3 text-lg font-semibold rounded-full bg-indigo-600 text-white hover:bg-indigo-700 transition duration-200 shadow-md disabled:opacity-50" disabled>
                    Compare & Generate Excel Report (.xlsx)
                </button>
                <button onclick="summarizeInsights()" id="llmButton" class="px-6 py-3 text-lg font-semibold rounded-full bg-green-500 text-white hover:bg-green-600 transition duration-200 shadow-md disabled:opacity-50" disabled>
                    ✨ Summarize Comparison Insights
                </button>
            </div>

            <!-- 3. Status/Error Message -->
            <div id="statusMessage" class="text-center p-3 rounded-lg hidden"></div>
            <div id="llmResult" class="card p-4 bg-yellow-50 border-yellow-200 border-l-4 hidden mt-6">
                <h3 class="font-bold text-yellow-800 mb-2">LLM Data Quality Summary:</h3>
                <p id="llmSummaryText" class="text-yellow-700 whitespace-pre-line"></p>
            </div>


            <!-- 4. Result Preview Area -->
            <h2 id="previewHeader" class="text-2xl font-bold text-gray-800 pt-8 hidden">Comparison Preview (Max 100 Rows)</h2>
            <div id="comparisonPreview" class="w-full overflow-x-auto mt-4 max-h-96">
                <!-- Comparison table will be inserted here -->
            </div>
        </div>
    </div>

    <script>
        const API_URL = "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=";
        const apiKey = ""; // Canvas will provide this at runtime

        const statusMessage = document.getElementById('statusMessage');
        const previewHeader = document.getElementById('previewHeader');
        const comparisonPreview = document.getElementById('comparisonPreview');
        const compareButton = document.getElementById('compareButton');
        const llmButton = document.getElementById('llmButton');
        const csvFile1 = document.getElementById('csvFile1');
        const csvFile2 = document.getElementById('csvFile2');
        const pkColumnInput = document.getElementById('pkColumn');
        const pkLabel = document.getElementById('pkLabel');
        const pkHelpText = document.getElementById('pkHelpText');
        const llmResultDiv = document.getElementById('llmResult');
        const llmSummaryText = document.getElementById('llmSummaryText');

        // Global storage for the last successful comparison result
        let lastComparisonResult = null;
        let sourceRecordCount = 0;
        let destRecordCount = 0;

        // Get references to radio buttons
        const keyTypeSingle = document.getElementById('keyTypeSingle');
        const keyTypeComposite = document.getElementById('keyTypeComposite');

        // --- UI/UX Helper Functions ---

        /**
         * Updates the input field guidance based on the selected key type.
         */
        function handleKeyModeChange() {
            if (keyTypeSingle.checked) {
                pkLabel.textContent = "Primary Key Column Name (e.g., ID)";
                pkColumnInput.placeholder = "Enter a single column name";
                pkHelpText.textContent = "Only enter the name of the single unique column used for matching.";
            } else {
                pkLabel.textContent = "Composite Key Columns (e.g., FirstName,LastName,DOB)";
                pkColumnInput.placeholder = "Enter comma-separated column names";
                pkHelpText.textContent = "Enter two or more column names, separated by commas, to create a unique identifier.";
            }
        }
        
        // Add listeners for key type change
        keyTypeSingle.addEventListener('change', handleKeyModeChange);
        keyTypeComposite.addEventListener('change', handleKeyModeChange);
        
        /**
         * Utility to enable the button only when both files are selected.
         */
        function checkFilesReady() {
            if (csvFile1.files.length > 0 && csvFile2.files.length > 0) {
                compareButton.disabled = false;
            } else {
                compareButton.disabled = true;
            }
        }

        csvFile1.addEventListener('change', checkFilesReady);
        csvFile2.addEventListener('change', checkFilesReady);

        /**
         * Shows a temporary status or error message.
         * @param {string} message - The message content.
         * @param {string} type - 'success', 'error', or 'info'.
         */
        function showMessage(message, type = 'info') {
            statusMessage.textContent = message;
            statusMessage.className = 'text-center p-3 rounded-lg';
            statusMessage.classList.remove('hidden');

            switch (type) {
                case 'success':
                    statusMessage.classList.add('bg-green-100', 'text-green-800');
                    break;
                case 'error':
                    statusMessage.classList.add('bg-red-100', 'text-red-800');
                    break;
                case 'info':
                default:
                    statusMessage.classList.add('bg-blue-100', 'text-blue-800');
                    break;
            }

            // Clear after 5 seconds
            setTimeout(() => {
                statusMessage.classList.add('hidden');
            }, 5000);
        }

        /**
         * Utility for exponential backoff during API calls.
         * @param {Function} fn - The function to retry.
         * @param {number} maxRetries - Maximum number of retries.
         */
        async function withExponentialBackoff(fn, maxRetries = 5) {
            for (let i = 0; i < maxRetries; i++) {
                try {
                    return await fn();
                } catch (error) {
                    if (i === maxRetries - 1 || error.message.includes('400')) {
                        throw error;
                    }
                    const delay = Math.pow(2, i) * 1000 + Math.random() * 1000;
                    await new Promise(resolve => setTimeout(resolve, delay));
                }
            }
        }


        // --- Core Data Functions (Unchanged, as they already support both modes) ---

        /**
         * Parses a file using PapaParse.
         * @param {File} file - The file object.
         * @param {string} delimiter - The delimiter character (',' or '|').
         * @returns {Promise<Array<Object>>} - Parsed data rows.
         */
        function parseFile(file, delimiter) {
            return new Promise((resolve, reject) => {
                Papa.parse(file, {
                    header: true,
                    skipEmptyLines: true,
                    delimiter: delimiter,
                    complete: (results) => {
                        if (results.errors.length > 0) {
                            reject(new Error(`Parsing error in file: ${results.errors[0].message}`));
                            return;
                        }
                        resolve(results.data);
                    },
                    error: (error) => {
                        reject(new Error(error.message));
                    }
                });
            });
        }
        
        /**
         * Generates a composite key string from a data row and a list of column names.
         * The key is trimmed and converted to upper case for robust, case-insensitive, and whitespace-agnostic matching.
         * @param {Object} row - The data row object.
         * @param {Array<string>} pkColumns - Array of column names to concatenate.
         * @returns {string} - The composite key.
         */
        function getCompositeKey(row, pkColumns) {
            // Use a highly unlikely separator (e.g., triple pipe)
            return pkColumns.map(col => (row[col] || '').trim().toUpperCase()).join('|||');
        }

        /**
         * Core comparison logic: Matches records and finds cell-level differences using a composite key.
         */
        function performComparison(sourceData, destData, compositeKeyColumns) {
            // 1. Build a Map of Source Data for quick lookup using the composite key
            const sourceMap = new Map();
            sourceData.forEach(row => {
                const compositeKey = getCompositeKey(row, compositeKeyColumns);
                if (compositeKey) {
                    sourceMap.set(compositeKey, row);
                }
            });

            // 2. Identify all unique headers across both files
            const sourceKeys = sourceData.length > 0 ? Object.keys(sourceData[0]) : [];
            const destKeys = destData.length > 0 ? Object.keys(destData[0]) : [];
            const allUniqueHeaders = Array.from(new Set([...sourceKeys, ...destKeys]));
            
            const keySet = new Set(compositeKeyColumns);
            const nonKeyHeaders = allUniqueHeaders.filter(h => !keySet.has(h));

            const comparisonRows = [];
            const matchedPks = new Set();

            // 3. Compare Destination data against Source
            destData.forEach(destRow => {
                const compositeKey = getCompositeKey(destRow, compositeKeyColumns);
                const sourceRow = sourceMap.get(compositeKey);
                matchedPks.add(compositeKey);

                const comparisonRow = {
                    // Store key values individually for display/export
                    keyValues: compositeKeyColumns.map(h => ({
                        header: h,
                        // Use Source value if available, otherwise use Dest (for DESTINATION_ONLY)
                        source: sourceRow ? (sourceRow[h] || '') : (destRow[h] || ''),
                        dest: destRow[h] || '',
                    })),
                    status: sourceRow ? 'MATCHED' : 'DESTINATION_ONLY',
                    diffs: 0,
                    cells: {} // Stores data for non-key headers
                };

                // Compare non-key columns for differences
                nonKeyHeaders.forEach(header => {
                    const sourceValue = sourceRow ? (sourceRow[header] || '').trim() : '';
                    const destValue = (destRow[header] || '').trim();

                    // Comparison is based on trimmed values
                    const isDiff = sourceValue !== destValue;

                    if (isDiff) {
                        comparisonRow.diffs++;
                    }

                    comparisonRow.cells[header] = {
                        source: sourceValue,
                        dest: destValue,
                        isDiff: isDiff
                    };
                });

                if (comparisonRow.diffs > 0) {
                    comparisonRow.status = 'MISMATCHED';
                }
                comparisonRows.push(comparisonRow);
            });

            // 4. Identify Source-Only records (Deletions/Missing in Destination)
            sourceData.forEach(sourceRow => {
                const compositeKey = getCompositeKey(sourceRow, compositeKeyColumns);
                
                // If the key exists in sourceMap but wasn't matched against a dest row
                if (!matchedPks.has(compositeKey) && sourceMap.has(compositeKey)) {
                    const comparisonRow = {
                        keyValues: compositeKeyColumns.map(h => ({
                            header: h,
                            source: sourceRow[h] || '',
                            dest: '' // Destination is blank for SOURCE_ONLY
                        })),
                        status: 'SOURCE_ONLY',
                        diffs: 0, 
                        cells: {}
                    };

                    nonKeyHeaders.forEach(header => {
                        comparisonRow.cells[header] = {
                            source: sourceRow[header] || '',
                            dest: '', // Destination is blank
                            isDiff: true // Mark as diff since record is missing
                        };
                    });
                    comparisonRows.push(comparisonRow);
                }
            });
            
            return { 
                keyHeaders: compositeKeyColumns, 
                nonKeyHeaders: nonKeyHeaders, 
                rows: comparisonRows 
            };
        }

        // --- LLM Insight Generation Function ---

        function getComparisonMetrics(comparisonResult) {
            const { rows, nonKeyHeaders } = comparisonResult;
            let matchedCount = 0;
            let mismatchedCount = 0;
            let sourceOnlyCount = 0;
            let destOnlyCount = 0;
            const diffsPerField = nonKeyHeaders.reduce((acc, header) => {
                acc[header] = 0;
                return acc;
            }, {});

            rows.forEach(row => {
                switch (row.status) {
                    case 'MATCHED':
                        matchedCount++;
                        break;
                    case 'MISMATCHED':
                        mismatchedCount++;
                        // Count field-level diffs
                        Object.keys(row.cells).forEach(header => {
                            if (row.cells[header].isDiff) {
                                diffsPerField[header]++;
                            }
                        });
                        break;
                    case 'SOURCE_ONLY':
                        sourceOnlyCount++;
                        break;
                    case 'DESTINATION_ONLY':
                        destOnlyCount++;
                        break;
                }
            });

            // Convert diffsPerField to an array and sort descending
            const topDiffFields = Object.entries(diffsPerField)
                .sort(([, a], [, b]) => b - a)
                .slice(0, 5) // Get top 5 fields
                .map(([field, count]) => `${field} (${count})`);

            return {
                totalSource: sourceRecordCount,
                totalDestination: destRecordCount,
                matched: matchedCount,
                mismatched: mismatchedCount,
                sourceOnly: sourceOnlyCount,
                destOnly: destOnlyCount,
                topDiffFields: topDiffFields,
            };
        }

        async function summarizeInsights() {
            if (!lastComparisonResult) {
                showMessage("Please run the comparison first to generate results.", 'info');
                return;
            }
            
            llmResultDiv.classList.add('hidden');
            llmSummaryText.textContent = '';
            llmButton.disabled = true;
            llmButton.textContent = "Analyzing...";

            try {
                const metrics = getComparisonMetrics(lastComparisonResult);
                
                const prompt = `Analyze the following data comparison metrics for a Source vs. Destination CSV comparison. The goal is to identify key data quality issues in a concise, professional summary for a data analyst.

Total Source Records: ${metrics.totalSource}
Total Destination Records: ${metrics.totalDestination}
Matched Records (No Mismatch): ${metrics.matched}
Mismatched Records (Data Differences): ${metrics.mismatched}
Source-Only Records (Missing in Destination): ${metrics.sourceOnly}
Destination-Only Records (Extra in Destination): ${metrics.destOnly}
Top 5 Fields with Mismatches (Field Name and Count): ${metrics.topDiffFields.join(', ') || 'None'}

Provide a concise, 3-4 sentence executive summary focused on the magnitude of the errors and the highest priority fields that need investigation.`;

                const payload = {
                    contents: [{ parts: [{ text: prompt }] }],
                    systemInstruction: {
                        parts: [{ text: "You are a professional Data Quality Analyst. Provide a clear, actionable, and concise summary of the comparison results. Use simple markdown formatting (e.g., bolding) but no headers or lists." }]
                    },
                };

                const response = await withExponentialBackoff(() => fetch(API_URL + apiKey, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                }));
                
                if (!response.ok) {
                    throw new Error(`API call failed with status: ${response.status}`);
                }

                const result = await response.json();
                const summary = result.candidates?.[0]?.content?.parts?.[0]?.text || "Failed to generate summary.";
                
                llmSummaryText.textContent = summary;
                llmResultDiv.classList.remove('hidden');
                showMessage("Insights generated by Gemini API successfully.", 'success');

            } catch (error) {
                console.error("LLM Error:", error);
                llmSummaryText.textContent = `Error generating summary: ${error.message}`;
                llmResultDiv.classList.remove('hidden');
                showMessage("Failed to generate insights. Check console for details.", 'error');
            } finally {
                llmButton.disabled = false;
                llmButton.textContent = "✨ Summarize Comparison Insights";
            }
        }

        // --- Export and Render Functions (Unchanged) ---

        /**
         * Generates and triggers download of the Excel (.xlsx) file with styling.
         */
        function exportToExcel(comparisonResult) {
            const { keyHeaders, nonKeyHeaders, rows } = comparisonResult;
            
            // Define the style object for red font in SheetJS
            const RED_FONT_STYLE = {
                font: { name: "Inter", color: { rgb: "FFFF0000" } }
            };
            
            // Create a blank SheetJS workbook
            const wb = XLSX.utils.book_new();
            const ws = XLSX.utils.aoa_to_sheet([]);

            // 1. Write Headers (STATUS, Key Columns, then Non-Key Columns (Source/Dest))
            const headers = [{ v: 'STATUS', t: 's' }]; 
            
            keyHeaders.forEach(header => {
                headers.push({ v: `${header} (Key)`, t: 's' });
            });

            nonKeyHeaders.forEach(header => {
                headers.push({ v: `${header} (Source)`, t: 's' });
                headers.push({ v: `${header} (Destination)`, t: 's' });
            });
            
            XLSX.utils.sheet_add_aoa(ws, [headers.map(h => h.v)], { origin: 'A1' });

            // 2. Write Data Rows
            rows.forEach(row => {
                const rowData = [];
                
                // Add STATUS column
                rowData.push({ v: row.status, t: 's', s: row.status === 'SOURCE_ONLY' || row.status === 'DESTINATION_ONLY' ? RED_FONT_STYLE : {} });
                
                // Add Key Columns (using Source value as canonical)
                row.keyValues.forEach(kv => {
                    rowData.push({ v: kv.source, t: 's' }); 
                });

                // Add data for non-key columns (Source vs Destination)
                nonKeyHeaders.forEach(header => {
                    const cellData = row.cells[header];

                    // Source Cell
                    const sourceCell = { v: cellData ? cellData.source : '', t: 's' };
                    // Apply red style if the cell is mismatched
                    if (cellData && cellData.isDiff) {
                        sourceCell.s = RED_FONT_STYLE;
                    }
                    rowData.push(sourceCell);
                    
                    // Destination Cell
                    const destCell = { v: cellData ? cellData.dest : '', t: 's' };
                    if (cellData && cellData.isDiff) {
                        destCell.s = RED_FONT_STYLE;
                    }
                    rowData.push(destCell);
                });

                XLSX.utils.sheet_add_aoa(ws, [rowData], { origin: -1 });
            });

            // 3. Finalize and Download
            XLSX.utils.book_append_sheet(wb, ws, "Comparison Report");
            XLSX.writeFile(wb, "CSV_Comparison_Report.xlsx");
        }


        /**
         * Clears the UI and displays the comparison results in an HTML table.
         */
        function renderPreview(comparisonResult) {
            const { keyHeaders, nonKeyHeaders, rows } = comparisonResult;
            
            // Show header and clear previous content
            previewHeader.classList.remove('hidden');
            comparisonPreview.innerHTML = '';
            
            // Limit to 100 rows for performance
            const rowsToDisplay = rows.slice(0, 100);

            if (rowsToDisplay.length === 0) {
                 comparisonPreview.innerHTML = '<p class="text-center text-gray-500 p-8">No records found matching your comparison criteria or the files were empty.</p>';
                 return;
            }

            let html = '<table class="min-w-full divide-y divide-gray-300 rounded-xl overflow-hidden shadow-lg">';

            // Table Header Row 1 (Main Header)
            html += '<thead class="bg-gray-100 sticky top-0">';
            html += '<tr>';
            
            // Key Columns Header
            keyHeaders.forEach(header => {
                html += `<th class="px-3 py-3 text-xs font-medium text-gray-500 uppercase tracking-wider text-left">${header} (Key)</th>`;
            });
            
            // Status Header
            html += `<th class="px-6 py-3 text-xs font-medium text-gray-500 uppercase tracking-wider text-left">Status</th>`;
            
            // Non-Key Columns Header (spanning Source/Dest)
            nonKeyHeaders.forEach(header => {
                html += `<th colspan="2" class="px-6 py-3 text-xs font-medium text-gray-700 uppercase tracking-wider text-center border-l border-gray-300 bg-gray-200">${header}</th>`;
            });
            html += '</tr>';

            // Table Header Row 2 (Sub-Header for Source/Dest)
            html += '<tr>';
            
            // Placeholder for Key Columns + Status (single cell per key column)
            html += keyHeaders.map(() => '<th class="px-3 py-2 text-xs text-gray-500 uppercase tracking-wider text-left">Value</th>').join('');
            html += '<th class="px-6 py-2 text-xs text-gray-500 uppercase tracking-wider text-left"></th>'; // Status header placeholder

            // Source/Dest labels for non-key columns
            nonKeyHeaders.forEach(() => {
                html += '<th class="px-3 py-2 text-xs text-gray-600 font-semibold uppercase tracking-wider text-center border-l border-gray-300">Source</th>';
                html += '<th class="px-3 py-2 text-xs text-gray-600 font-semibold uppercase tracking-wider text-center">Dest</th>';
            });
            html += '</tr>';
            html += '</thead>';

            // Table Body
            html += '<tbody class="divide-y divide-gray-200 bg-white">';
            rowsToDisplay.forEach(row => {
                let rowClass = '';
                if (row.status === 'MATCHED') {
                    rowClass = 'matched-row';
                } else if (row.status === 'MISMATCHED') {
                    rowClass = 'unmatched-row';
                } else if (row.status === 'SOURCE_ONLY' || row.status === 'DESTINATION_ONLY') {
                    rowClass = 'bg-red-50';
                }

                html += `<tr class="${rowClass} hover:bg-gray-50 transition duration-100">`;
                
                // Key Column Values
                row.keyValues.forEach(kv => {
                    // Display the canonical key value (from source/dest based on row status)
                    html += `<td class="px-3 py-3 whitespace-nowrap text-sm font-medium text-gray-900">${kv.source}</td>`;
                });
                
                // Status
                html += `<td class="px-6 py-3 whitespace-nowrap text-xs font-semibold ${row.diffs > 0 || row.status !== 'MATCHED' ? 'text-red-600' : 'text-green-600'}">${row.status}</td>`;

                // Data Cells (Non-Key)
                nonKeyHeaders.forEach(header => {
                    const cell = row.cells[header];
                    if (cell) {
                        const cellClass = cell.isDiff ? 'mismatch-cell' : 'text-gray-700';
                        
                        // Source Value
                        html += `<td class="px-3 py-2 whitespace-nowrap text-sm ${cellClass} border-l border-gray-200">${cell.source}</td>`;
                        // Destination Value
                        html += `<td class="px-3 py-2 whitespace-nowrap text-sm ${cellClass}">${cell.dest}</td>`;
                    }
                });
                
                html += '</tr>';
            });
            html += '</tbody>';
            html += '</table>';

            comparisonPreview.innerHTML = html;
        }

        // --- Main Execution Function ---

        async function compareAndExport() {
            const file1 = csvFile1.files[0];
            const file2 = csvFile2.files[0];
            
            const pkColumnInputVal = pkColumnInput.value.trim();
            const isSingleKeyMode = keyTypeSingle.checked;
            
            // Get the list of column names, trimming whitespace
            const compositeKeyColumns = pkColumnInputVal.split(',')
                .map(col => col.trim())
                .filter(col => col.length > 0);

            if (!file1 || !file2 || compositeKeyColumns.length === 0) {
                showMessage("Please select both files and specify at least one column name for the key.", 'error');
                return;
            }

            // Additional validation for single key mode
            if (isSingleKeyMode && compositeKeyColumns.length > 1) {
                showMessage("In 'Single Primary Key' mode, please enter only one column name.", 'error');
                return;
            }

            compareButton.disabled = true;
            llmButton.disabled = true;
            compareButton.textContent = "Processing... (This may take a moment)";
            showMessage("Parsing files and performing comparison...", 'info');
            llmResultDiv.classList.add('hidden'); // Hide previous LLM result

            try {
                // 1. Parse Files (Source: Comma, Destination: Pipe)
                const sourceData = await parseFile(file1, ',');
                const destData = await parseFile(file2, '|');
                
                sourceRecordCount = sourceData.length;
                destRecordCount = destData.length;

                if (sourceRecordCount === 0 || destRecordCount === 0) {
                    throw new Error("One or both files are empty or could not be parsed correctly.");
                }

                // Check if all key columns exist in headers of both files
                const sourceHeaders = Object.keys(sourceData[0]);
                const destHeaders = Object.keys(destData[0]);
                
                for (const key of compositeKeyColumns) {
                    if (!sourceHeaders.includes(key) || !destHeaders.includes(key)) {
                        throw new Error(`Key Column '${key}' not found in headers of both files. Please check spelling/casing.`);
                    }
                }

                // 2. Perform Comparison
                const comparisonResult = performComparison(sourceData, destData, compositeKeyColumns);
                lastComparisonResult = comparisonResult; // Store result globally

                // 3. Render HTML Preview
                renderPreview(comparisonResult);

                // 4. Generate and Download Excel Report
                exportToExcel(comparisonResult);
                
                // 5. Enable LLM button
                llmButton.disabled = false;

                showMessage(`Successfully compared ${sourceRecordCount} source records against ${destRecordCount} destination records. Excel file downloaded! (See Preview below)`, 'success');

            } catch (error) {
                console.error("Comparison Error:", error);
                // Clear state on error
                lastComparisonResult = null;
                sourceRecordCount = 0;
                destRecordCount = 0;
                llmButton.disabled = true;
                
                // Show a clear message if the preview is empty due to an error
                if (error.message.includes("files are empty")) {
                    comparisonPreview.innerHTML = '<p class="text-center text-red-500 p-8">Error: One or both files are empty. Please check your data.</p>';
                    previewHeader.classList.remove('hidden');
                } else if (error.message.includes("Key Column")) {
                    comparisonPreview.innerHTML = `<p class="text-center text-red-500 p-8">Error: Key column mismatch. ${error.message}</p>`;
                    previewHeader.classList.remove('hidden');
                } else {
                     comparisonPreview.innerHTML = `<p class="text-center text-red-500 p-8">An unexpected error occurred: ${error.message}</p>`;
                     previewHeader.classList.remove('hidden');
                }
                
                showMessage(`Error: ${error.message}`, 'error');
            } finally {
                compareButton.disabled = false;
                compareButton.textContent = "Compare & Generate Excel Report (.xlsx)";
            }
        }

        // Initialize button and UI state
        checkFilesReady();
        handleKeyModeChange(); // Set initial label/placeholder
    </script>
</body>
</html>
